# -*- coding: utf-8 -*-

#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      cabarry
#
# Created:     26/07/2018
# Copyright:   (c) cabarry 2018
# Licence:     <your licence>
#-------------------------------------------------------------------------------

##---------------------------------------MODULES
import time
print "Début : "+str(time.time())

import osgeo
from osgeo import ogr, osr, gdal
from osgeo.gdalnumeric import *
from osgeo.gdalconst import *

import numpy as np
import os
import shutil
import string
import sys

print "Imports : "+str(time.time())

##---------------------------------------Enrigstrement des données récoltées sur l'interface
ls_gid=[]
folder_out = "..//tableaux_recup"

#print(input_str_data)
for i in os.listdir(folder_out) :
    if len(i.split("_")) > 1:
        ls_gid.append(int((i.split("_")[1]).split(".")[0]))

if len(ls_gid)>0 :
    it = max(ls_gid)
else :
    it = 0

rep_data="..//sorties_script"
data = "..//tableaux_recup//catalogue_"+str(it)+".csv"

##---------------------------------------Variables
data_infos = open("..//tableaux_recup//infos_"+str(it)+".csv","r")
variables_parametrees = []
for row in data_infos :
    variables_parametrees.append(row.split(";"))
print variables_parametrees
emprise = variables_parametrees[0][0]
tolerance=variables_parametrees[0][1]
print ("--")
print emprise
print tolerance

pixel_size=100.0
proj_leaflet= '''GEOGCS["GCS_WGS_1984",
    DATUM["WGS_1984",
        SPHEROID["WGS_84",6378137,298.257223563]],
    PRIMEM["Greenwich",0],
    UNIT["Degree",0.017453292519943295]]'''

#Sortie
result=rep_data+r"\final\resut.tif"
result_contmax=rep_data+r"\final\resut_contmax.tif"
result_nodata=rep_data+r"\final\resut_nodata.tif"
result_tolerance=rep_data+r"\final\resut_tolerance.tif"

#Implémentées dans la boucle
ls_layers=[]
ls_layers_abs=[]
ls_type=[]
ls_type_abs=[]
ls_pond=[]
ls_pond_abs=[]
##facteurs=[]
##alpha = string.ascii_lowercase
ind = -1
##ind1234=0
##ind56=0
##formule = ""
content  = open(data,"r")

##---------------------------------------Creation du repertoire de fichier temporaire (necessaire pour une boucle)
rep_temp= rep_data+r"\temp"+str(it)+"_"+str(int(time.time()))
var = "temp_"+str(it)+"_"+str(int(time.time()))

if var not in os.listdir(rep_data) :
    print("Creation du dossier \'temp\' "+str(time.time()))
    os.mkdir(rep_temp)
else :
    print("Dossier \'temp\' existant "+str(time.time()))

##---------------------------------------Traitements du fichier d'emprise
# Define pixel_size and NoData value of new raster
NoData_value = -9999
print("b")
#Layer source
emprise_ds = ogr.Open(emprise)
emprise_layer = emprise_ds.GetLayer()
source_srs = emprise_layer.GetSpatialRef()
print ("a")
# Filename of the raster Tiff that will be created
raster_fn = rep_temp+r'\raster_emprise.tif'

#Changement de projection
### Getting spatial reference of input raster
##srs = osr.SpatialReference()
##srs.ImportFromWkt(source_srs)
##
### WGS84 projection reference
##OSR_WGS84_REF = osr.SpatialReference()
##OSR_WGS84_REF.ImportFromEPSG(4326)
##
### OSR transformation
##wgs84_to_image_trasformation = osr.CoordinateTransformation(OSR_WGS84_REF, srs)

# Open the data source and read in the extent
x_min, x_max, y_min, y_max = emprise_layer.GetExtent()
#Il faut convertir ces points (et non la couche)  en truc style 2154 pr voir des coordonnées projetées (alors que genre le 4326 est en géographique, donc pour calculer uen distance en faisant xmax-xmin c pas possible :/ et après on reprojettera en ... 4326!!
# Setup the source projection - you can also import from epsg, proj4...
source = osr.SpatialReference()
plouf =  emprise_layer.GetSpatialRef().ExportToWkt()
source.ImportFromWkt(plouf)
# The target projection
target = osr.SpatialReference()
target.ImportFromEPSG(2154)
# Create the transform - this can be used repeatedly
transform = osr.CoordinateTransformation(source, target)

print 'xmin : ',x_min,' xmax : ',x_max,' ymin : ',y_min,' ymax : ',y_max
for feature in emprise_layer: #inLayer is always of size one because polygon is a unique value
    geom=feature.GetGeometryRef()
    print geom.GetEnvelope()

# Transform the point. You can also create an ogr geometry and use the more generic `point.Transform()`
n_xmin, n_ymin,burp = transform.TransformPoint(x_min, y_min)
n_xmax, n_ymax,barp = transform.TransformPoint(x_max, y_max)
##x_res = int((n_xmax - n_xmin) / pixel_size)
##y_res = int((n_ymax - n_ymin) / pixel_size)
x_res = int((x_max -x_min) / pixel_size)
y_res = int((y_max - y_min) / pixel_size)

print 'xmin : ',x_min,' xmax : ',x_max,' ymin : ',y_min,' ymax : ',y_max
print x_res

# Create the destination data source
tar_emp_ds = gdal.GetDriverByName('GTiff').Create(raster_fn, x_res, y_res, 1,gdal.GDT_Float32)
tar_emp_ds.SetGeoTransform((n_xmin, pixel_size, 0, n_ymax, 0, -pixel_size))
tar_emp_ds.SetProjection(source_srs.ExportToWkt())

band_emp_ras = tar_emp_ds.GetRasterBand(1)
band_emp_ras.SetNoDataValue(NoData_value)

#################☺A FAIRE CA EN FAIT https://www.google.fr/search?q=gdal+reprojeter&oq=gdal+reprojeter&aqs=chrome..69i57.1551j1j4&sourceid=chrome&ie=UTF-8

#srs = osr.SpatialReference()
#srs.ImportFromEPSG(2154)

# Rasterize
##gdal.RasterizeLayer(tar_emp_ds, [1], emprise_layer, burn_values=[1])

b = band_emp_ras.ReadAsArray()#.astype(np.float)
print("Traitements sur l'emprise : "+str(time.time()))

##---------------------------------------Bouclage
for i in content :
    row = i.split(";")
    print " "
    print "Boucle "+row[0]+" : "+str(time.time())

    if ind > -1 and row[2]!="0":
        row = i.split(";")
        inputt = row[1]
        data_type=row[2]

        ##---------------------------------------Rasterisation    (en format Byte, à copier pour le deuxième cas où il faudra un floatant)
        source_ds = ogr.Open(inputt)
        source_layer = source_ds.GetLayer()
        source_src_data = source_layer.GetSpatialRef()

        raster_fn =rep_temp+r"\rast_byte_"+ i.split(".")[0]+".tif"
        target_ds = gdal.GetDriverByName('GTiff').Create(raster_fn, x_res, y_res,1, gdal.GDT_Byte)
        target_ds.SetGeoTransform((x_min, pixel_size, 0, y_max, 0, -pixel_size))
        target_ds.SetProjection(source_src_data.ExportToWkt())

        band = target_ds.GetRasterBand(1)
        band.SetNoDataValue(NoData_value)
        band.SetUnitType("m")

        # Rasterize
        gdal.RasterizeLayer(target_ds, [1], source_layer, burn_values=[1])

        ##---------------------------------------Raster de distance
        if data_type=="1" or data_type=="2" or data_type=="7" or data_type=="8":

            # Sortie
            proxy_fn = rep_temp+r'\proximity_'+i.split(".")[0]+'.tif'
            dst_ds = gdal.GetDriverByName( 'GTiff' ).Create(proxy_fn , x_res, y_res, 1,gdal.GDT_Float32)
            dst_ds.SetGeoTransform((x_min, pixel_size, 0, y_max, 0, -pixel_size))
            dst_ds.SetProjection(source_src_data.ExportToWkt())

            dst_band = dst_ds.GetRasterBand(1)
            dst_band.SetNoDataValue(NoData_value)
            dst_band.SetUnitType("m")

            # Fonction proximity
            gdal.ComputeProximity(band, dst_band )   #ATTENTION, renvoie des valeurs en hm et non en m

            ##---------------------------------------Calculatrices
            a = dst_band.ReadAsArray()#.astype(np.float)
            #Calcul 1 : découpe
            c = np.where(b==1,a,NoData_value)
            #Calcul 2 : normalisation (à faire après pour le maximum soit celui de l'emprise et pas de tout le rectangle
            maxi_area = np.max(c)

            #Si distance amx  -> noramlisation particulière enfonction de la valeur de la distance max et de la comapraison avec le maximum
            if row[4] and float(row[4])>0 :
                dist_buff=float(row[4])
                #Positifs
                if data_type=="1" or data_type=="7":
                    maxOk = min(maxi_area,dist_buff)
                    d = np.where(c>maxOk,1,c/maxOk)
                else : #cad data_type=3 ou 4
                    if maxi_area>dist_buff:
                        d = np.where(c<dist_buff,0,((c-dist_buff)/(maxi_area-dist_buff)))
                    else:
                        d = np.where(c==NoData_value,NoData_value,1)


            #Sinon, noramlsiation par rapport à la velru maximale trouvée sur le raster de distance
            else:
                d = np.where(c>maxi_area,1,c/maxi_area)

            #Ajustement no_data (les valeurs ont été modifiées
            e= np.where(d<0,NoData_value,d)

            #Ecriture
            dst_band.WriteArray(e)

            ##---------------------------------------Fermetures spécifiques
            dst_band = None
            dst_ds = None

            #Listes pour le calcul final
            ls_layers.append(proxy_fn)
            ls_type.append(data_type)
            ls_pond.append(row[3])

            print "Raster de distance (type "+data_type+") : "+str(time.time())
        if data_type=="3" or data_type=="4" or data_type=="5" or data_type=="6" or data_type=="7" or data_type=="8":
            ##Rasterisation (!!! en format Float !!!)
##            raster_fn =rep_temp+r"\rast_float_"+ i.split(".")[0]+".tif"
##
##            target_ds = gdal.GetDriverByName('GTiff').Create(raster_fn, x_res, y_res,1, gdal.GDT_Byte)
##            target_ds.SetGeoTransform((x_min, pixel_size, 0, y_max, 0, -pixel_size))
##            target_ds.SetProjection(source_srs.ExportToWkt())
##
##            band = target_ds.GetRasterBand(1)
##            band.SetNoDataValue(NoData_value)
##            band.SetUnitType("m")
##
##            # Rasterize
##            gdal.RasterizeLayer(target_ds, [1], source_layer, burn_values=[1])


            #Application des buffers si présent, et les types ne sont pas 7 et 8(on choisit à ce moment une distance limite et non un buffer)
            #https://gis.stackexchange.com/questions/122736/python-buffer-in-a-line-using-gdal
            if row[4] and float(row[4])>0 and data_type!="7" and data_type!="8":

                #Application du buffer
                dist_buff=float(row[4])
                outputBufferfn = rep_temp+'/buffer_'+str(dist_buff)+'_'+i.split(".")[0]+'.shp'
                output_prj = rep_temp+'/buffer_'+str(dist_buff)+'_'+i.split(".")[0]+'.prj'

                shpdriver = ogr.GetDriverByName('ESRI Shapefile')
                outputBufferds = shpdriver.CreateDataSource(outputBufferfn)
                bufferlyr = outputBufferds.CreateLayer(outputBufferfn, geom_type=ogr.wkbPolygon)

                featureDefn = bufferlyr.GetLayerDefn()
                for feature in source_layer:
                    ingeom = feature.GetGeometryRef()
                    geomBuffer = ingeom.Buffer(dist_buff)

                    outFeature = ogr.Feature(featureDefn)
                    outFeature.SetGeometry(geomBuffer)
                    bufferlyr.CreateFeature(outFeature)

                prj = open(output_prj, 'w')
                #proyeccion = 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]'
                prj.write(source_src_data.ExportToWkt())
                prj.close()

                #Afermer et réouvrir (je sais pas pk, on doit pouvoir éviter ça)
                outputBufferds.Destroy()
                source_buff = ogr.Open(outputBufferfn)
                source_buff_lay = source_buff.GetLayer()


                #Rasterisation du buffer (écrase la précédemet écriture de target_ds, pas raev puisque le cas 1 est exécuté avant)
                gdal.RasterizeLayer(target_ds, [1], source_buff_lay, burn_values=[1])
                source_buff = None

                print "Buffer ok : ",time.time()

            #On repart de target_ds (le raster !) pour les passer au découpage puis...
            #Il faut le copier dans un floattant et donc
            raster_float =rep_temp+r"\rast_float_"+ i.split(".")[0]+".tif"

            target_float_ds = gdal.GetDriverByName('GTiff').Create(raster_float, x_res, y_res,1, gdal.GDT_Float32)
            target_float_ds.SetGeoTransform((x_min, pixel_size, 0, y_max, 0, -pixel_size))
            target_float_ds.SetProjection(source_src_data.ExportToWkt())

            band_float = target_float_ds.GetRasterBand(1)
            band_float.SetNoDataValue(NoData_value)
            band_float.SetUnitType("m")


            a = band.ReadAsArray()
            c = np.where(a==1,1,0)
            d = np.where(b==1,c,NoData_value)
            band_float.WriteArray(d)

            #Listes pour le calcul final
            if data_type == "3" or  data_type == "4" :
                ls_layers.append(raster_float)
                ls_type.append(data_type)
                ls_pond.append(row[3])
            elif data_type == "5" or  data_type == "6" or data_type=="7" or data_type=="8":
                ls_layers_abs.append(raster_float)
                ls_type_abs.append(data_type)
                ls_pond_abs.append(row[3])

            print "Pas de raster de distance (type "+data_type+") : "+str(time.time())

            band_float = None
            target_float_ds = None

        ##---------------------------------------Fermetures générales
        target_ds = None
        band  = None
        source_ds.Destroy()
    ind+=1

print "Traitements individuels terminés : "+str(time.time())

##---------------------------------------Fermetures générales
#Tableaux vides en partant de l'emprise (ptetr redondant?)  et raster de sortie
t = np.where(b>=0,0,NoData_value)

result_fn = rep_temp+r'\resultat.tif'
result_fn_255 = rep_temp+r'\resultat_255.tif'
result_fn_255_3857 = rep_temp+r'\resultat_255_3857.tif'
result_fn_255_png = rep_temp+r'\resultat.png'
result_contmax_fn = rep_temp+r'\resultat_contmax.tif'
result_nodata_fn = rep_temp+r'\resultat_nodata.tif'

result_ds = gdal.GetDriverByName('GTiff').Create(result_fn, x_res, y_res, 1,gdal.GDT_Float32)
result_ds.SetGeoTransform((x_min, pixel_size, 0, y_max, 0, -pixel_size))
result_ds.SetProjection(source_srs.ExportToWkt())
result_band  = result_ds.GetRasterBand(1)
result_band.SetNoDataValue(NoData_value)
result_band.SetUnitType("m")

result_ds_255 = gdal.GetDriverByName('GTiff').Create(result_fn_255, x_res, y_res, 4,gdal.GDT_Float32)
result_ds_255.SetGeoTransform((x_min, pixel_size, 0, y_max, 0, -pixel_size))
result_ds_255.SetProjection(source_srs.ExportToWkt())
result_band_255_1  = result_ds_255.GetRasterBand(1)
result_band_255_2 = result_ds_255.GetRasterBand(2)
result_band_255_3 = result_ds_255.GetRasterBand(3)
result_band_255_4 = result_ds_255.GetRasterBand(4)

result_contmax_ds = gdal.GetDriverByName('GTiff').Create(result_contmax_fn, x_res, y_res, 1,gdal.GDT_Float32)
result_contmax_ds.SetGeoTransform((x_min, pixel_size, 0, y_max, 0, -pixel_size))
result_contmax_ds.SetProjection(source_srs.ExportToWkt())
result_contmax_band  = result_contmax_ds.GetRasterBand(1)
result_contmax_band.SetNoDataValue(NoData_value)
result_contmax_band.SetUnitType("m")

result_nodata_ds = gdal.GetDriverByName('GTiff').Create(result_nodata_fn, x_res, y_res, 1,gdal.GDT_Float32)
result_nodata_ds.SetGeoTransform((x_min, pixel_size, 0, y_max, 0, -pixel_size))
result_nodata_ds.SetProjection(source_srs.ExportToWkt())
result_nodata_band  = result_nodata_ds.GetRasterBand(1)
result_nodata_band.SetNoDataValue(NoData_value)
result_nodata_band.SetUnitType("m")

##Ajout
total = 0.0
for x in range(len(ls_layers)) :
    ly = ls_layers[x]
    ty = ls_type[x]
    layer_src = gdal.Open(ly)

    band_ly = layer_src.GetRasterBand(1)
    pond=float(ls_pond[x])

    n = band_ly.ReadAsArray()#.astype(np.float)
    if ty=="1" or ty=="7" or ty=="4": #Oui parce que la distance (1) équivautà l'éloignement, alors que pour le éprimètre, 1 sigifie à l'intérieur de
        t = np.where(n==NoData_value,NoData_value,t+pond*n)
    elif ty=="2" or ty=="8" or ty=="3":
        t = np.where(n==NoData_value,NoData_value,t+pond*(1-n))

    total = total + pond
if len(ls_layers) >0 :
    t = np.where(n==NoData_value,NoData_value,t/total)
    result_band.WriteArray(t)

    t255 = np.where(n==NoData_value,NoData_value,t*255)
    result_band_255_1.WriteArray(t255)
    result_band_255_2.WriteArray(t255)
    result_band_255_3.WriteArray(t255)

    t255_op = np.where(n==NoData_value,0,255)
    result_band_255_4.WriteArray(t255_op)

u=t
v=t
for x in range(len(ls_layers_abs)) :
    ly = ls_layers_abs[x]
    ty = ls_type_abs[x]
    layer_src = gdal.Open(ly)
    band_ly = layer_src.GetRasterBand(1)
    pond=float(ls_pond_abs[x])

    n = band_ly.ReadAsArray()#.astype(np.float)
    if ty=="5" or ty=="7": #Oui parce que la distance (1) équivautà l'éloignement, alors que pour le éprimètre, 1 sigifie à l'intérieur de
        u = np.where(n>0.5,u,NoData_value)
        v = np.where(n>0.5,v,1)
    elif ty=="6" or ty=="8":
        u = np.where(n>0.5,NoData_value,u)
        v = np.where(n>0.5,1,v)

if len(ls_layers_abs) >0 :
    result_nodata_band.WriteArray(u)
    result_contmax_band.WriteArray(v)

#- Reporjection du raster destiné à devenir un PNG
gdal.Warp(result_fn_255_3857,result_ds_255,dstSRS='EPSG:3857')
result_ds_255_3857 = gdal.Open(result_fn_255_3857)

#----Conversion du PNG
saveOptions = []
saveOptions.append("QUALITY=100")

# Obtains a JPEG GDAL driver
jpegDriver = gdal.GetDriverByName("PNG")

# Create the .JPG file
blop = jpegDriver.CreateCopy(result_fn_255_png, result_ds_255_3857, 0, saveOptions)


##---------------------------------------Fermetures
tar_emp_ds = None
emprise_ds.Destroy()


result_band = None
result_ds = None

result_band_255_1 = None
result_band_255_2 = None
result_band_255_3 = None
result_band_255_4 = None
result_ds_255 = None
result_ds_255_3857 = None

result_contmax_band = None
result_contmax_ds = None

result_nodata_band = None
result_nodata_ds = None
